#pragma kernel CubeMapToEquirectangular
#pragma kernel CubeMapToEquirectangularPositiveY
#pragma kernel CubeMapToEquirectangularNegativeY

RWStructuredBuffer<uint> result;
Texture2D<float4> cubemapFacePositiveY;
Texture2D<float4> cubemapFaceNegativeY;
Texture2D<float4> cubemapFacePositiveX;
Texture2D<float4> cubemapFaceNegativeX;
Texture2D<float4> cubemapFacePositiveZ;
Texture2D<float4> cubemapFaceNegativeZ;
SamplerState MyLinearClampSampler;
int equirectangularWidth;
int equirectangularHeight;
int ssaaFactor;
int cubemapSize;
int startY;

[numthreads(32,32,1)] // Must match threadsX, threadsY in CapturePanorama.cs
void CubeMapToEquirectangular (uint3 dtid : SV_DispatchThreadID)
{
	static const float pi = 3.14159265f;
	float4 totalColor = float4(0.0f, 0.0f, 0.0f, 0.0f);

	int2 pos = int2(dtid.x, dtid.y + startY);
	int2 loopStart = pos * ssaaFactor;
	int2 loopEnd = loopStart + int2(ssaaFactor, ssaaFactor);

	for (int y = loopStart.y; y < loopEnd.y; y++)
	{
		for (int x = loopStart.x; x < loopEnd.x; x++)
		{
			float xcoord = (float)x / (equirectangularWidth * ssaaFactor);
			float ycoord = (float)y / (equirectangularHeight * ssaaFactor);
			float latitude = (ycoord - 0.5f) * pi;
			float longitude = (xcoord * 2.0f - 1.0f) * pi;

			float cosLat = cos(latitude);
			float equirectRayDirectionX = cosLat * sin (longitude);
			float equirectRayDirectionY = sin (latitude);
			float equirectRayDirectionZ = cosLat * cos (longitude);

			float distance;
			float u, v;
			float maxValue = 1.0f - 1.0f/cubemapSize;

			distance = 1.0f / equirectRayDirectionY;
			u = equirectRayDirectionX * distance; v = equirectRayDirectionZ * distance;
			if (u * u <= 1 && v * v <= 1) {
				v = (v + 1.0f) * 0.5f;
				v = min(v, maxValue);
				if (equirectRayDirectionY > 0.0f) {
					u = (u + 1.0f) * 0.5f;
					u = min(u, maxValue);
			
					totalColor += cubemapFacePositiveY.SampleLevel(MyLinearClampSampler, float2(u,v), 0);
					continue;
				} else {
					u = -u;
					u = (u + 1.0f) * 0.5f;
					u = min(u, maxValue);
			
					totalColor += cubemapFaceNegativeY.SampleLevel(MyLinearClampSampler, float2(u,v), 0);
					continue;
				}
			}
	
			distance = 1.0f / equirectRayDirectionX;
			u = -equirectRayDirectionZ * distance; v = equirectRayDirectionY * distance;
			if (u * u <= 1 && v * v <= 1) {
				u = (u + 1.0f) * 0.5f;
				u = min(u, maxValue);
				if (equirectRayDirectionX > 0.0f) {
					v = -v;
					v = (v + 1.0f) * 0.5f;
					v = min(v, maxValue);
			
					totalColor += cubemapFacePositiveX.SampleLevel(MyLinearClampSampler, float2(u,v), 0);
					continue;
				} else {
					v = (v + 1.0f) * 0.5f;
					v = min(v, maxValue);
			
					totalColor += cubemapFaceNegativeX.SampleLevel(MyLinearClampSampler, float2(u,v), 0);
					continue;
				}
			}

			distance = 1.0f / equirectRayDirectionZ;
			u = equirectRayDirectionX * distance; v = equirectRayDirectionY * distance;
			if (u * u <= 1 && v * v <= 1) {
				u = (u + 1.0f) * 0.5f;
				u = min(u, maxValue);
				if (equirectRayDirectionZ > 0.0f) {
					v = -v;
					v = (v + 1.0f) * 0.5f;
					v = min(v, maxValue);
			
					totalColor += cubemapFacePositiveZ.SampleLevel(MyLinearClampSampler, float2(u,v), 0);
					continue;
				} else {
					v = (v + 1.0f) * 0.5f;
					v = min(v, maxValue);
			
					totalColor += cubemapFaceNegativeZ.SampleLevel(MyLinearClampSampler, float2(u,v), 0);
					continue;
				}
			}
		}
	}

	totalColor /= ssaaFactor * ssaaFactor;
	totalColor *= 255.0;
	result[(dtid.y * equirectangularWidth) + dtid.x] = ((int)totalColor.r << 16) | ((int)totalColor.g << 8) | (int)totalColor.b;
}

[numthreads(32,32,1)] // Must match threadsX, threadsY in CapturePanorama.cs
void CubeMapToEquirectangularPositiveY (uint3 dtid : SV_DispatchThreadID)
{
	static const float pi = 3.14159265f;
	float4 totalColor = float4(0.0f, 0.0f, 0.0f, 0.0f);

	int2 pos = int2(dtid.x, dtid.y + startY);
	int2 loopStart = pos * ssaaFactor;
	int2 loopEnd = loopStart + int2(ssaaFactor, ssaaFactor);

	for (int y = loopStart.y; y < loopEnd.y; y++)
	{
		for (int x = loopStart.x; x < loopEnd.x; x++)
		{
			float xcoord = (float)x / (equirectangularWidth * ssaaFactor);
			float ycoord = (float)y / (equirectangularHeight * ssaaFactor);
			float latitude = (ycoord - 0.5f) * pi;
			float longitude = (xcoord * 2.0f - 1.0f) * pi;

			float cosLat = cos(latitude);
			float equirectRayDirectionX = cosLat * sin (longitude);
			float equirectRayDirectionY = sin (latitude);
			float equirectRayDirectionZ = cosLat * cos (longitude);

			float distance = 1.0f / equirectRayDirectionY;
			float u = equirectRayDirectionX * distance, v = equirectRayDirectionZ * distance;
			v = (v + 1.0f) * 0.5f;
			u = (u + 1.0f) * 0.5f;
			totalColor += cubemapFacePositiveY.SampleLevel(MyLinearClampSampler, float2(u,v), 0);
		}
	}

	totalColor /= ssaaFactor * ssaaFactor;
	totalColor *= 255.0;
	result[(dtid.y * equirectangularWidth) + dtid.x] = ((int)totalColor.r << 16) | ((int)totalColor.g << 8) | (int)totalColor.b;
}

[numthreads(32,32,1)] // Must match threadsX, threadsY in CapturePanorama.cs
void CubeMapToEquirectangularNegativeY (uint3 dtid : SV_DispatchThreadID)
{
	static const float pi = 3.14159265f;
	float4 totalColor = float4(0.0f, 0.0f, 0.0f, 0.0f);

	int2 pos = int2(dtid.x, dtid.y + startY);
	int2 loopStart = pos * ssaaFactor;
	int2 loopEnd = loopStart + int2(ssaaFactor, ssaaFactor);

	for (int y = loopStart.y; y < loopEnd.y; y++)
	{
		for (int x = loopStart.x; x < loopEnd.x; x++)
		{
			float xcoord = (float)x / (equirectangularWidth * ssaaFactor);
			float ycoord = (float)y / (equirectangularHeight * ssaaFactor);
			float latitude = (ycoord - 0.5f) * pi;
			float longitude = (xcoord * 2.0f - 1.0f) * pi;

			float cosLat = cos(latitude);
			float equirectRayDirectionX = cosLat * sin (longitude);
			float equirectRayDirectionY = sin (latitude);
			float equirectRayDirectionZ = cosLat * cos (longitude);

			float distance = 1.0f / equirectRayDirectionY;
			float u = equirectRayDirectionX * distance, v = equirectRayDirectionZ * distance;
			v = (v + 1.0f) * 0.5f;
			u = -u;
			u = (u + 1.0f) * 0.5f;
			
			totalColor += cubemapFaceNegativeY.SampleLevel(MyLinearClampSampler, float2(u,v), 0);
		}
	}

	totalColor /= ssaaFactor * ssaaFactor;
	totalColor *= 255.0;
	result[(dtid.y * equirectangularWidth) + dtid.x] = ((int)totalColor.r << 16) | ((int)totalColor.g << 8) | (int)totalColor.b;
}
